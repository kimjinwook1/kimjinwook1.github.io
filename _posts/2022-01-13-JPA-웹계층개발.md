--- 
layout: post
title: JPA - 웹 계층 개발
description: 
summary: 
tags: JPA
minute: 1
- - - -

# 2022-01-13

데이터가 가지고 있는 쪽에 비즈니스 로직이 있는 것이 가장 좋다.(응집력이 생김)

**참고**
주문 서비스의 주문과 주문취소 메서드를 보면 비즈니스 로직 대부분이 엔티티에 있다.
* 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할을 한다. 이처럼 엔티티가 비즈니스 로직을 가지고 객체 지향의 특성을 적극 활용하는 것을 **도메인 모델 패턴**이라 한다.
* 반대로 엔티티에는 비즈니스 로직이 거의 없고 서비스 계층에서 대부분 비즈니스 로직을 처리하는 것을 **트랜잭션 스크립트 패턴** 이라 한다.

도메인 모델 패턴 (http://martinfowler.com/eaaCatalog/domainModel.html)
트랜잭션 스크립트 패턴 (http://martinfowler.co,/eaaCatalog/transactionScript.html)

한 프로젝트 안에서도 트랜잭션 스크립트 패턴과 도메인 모델 패턴 이 양립한다. 현재 나의 프로젝트에 더 맞는 것을 판단하여 사용하면 된다.


## 동적 쿼리 -> Querydsl사용
* JPA Criteria 는 사용법도 어렵고 어떤 쿼리가 사용되고 있는지 눈에 한번에 들어오지 않는다.
그렇기에 유지보수에 취약하다는 단점이 있다.

타임리프
th:object=“${memberForm}” -> modelAttribute 를 통해 저장해준 값을 꺼내온다.

th:field=“*{name}” -> memberForm에 있는 객체에 접근할 수 있음, th:field를 적어 주면 html에 id, name을 *{}안에 있는 걸로 만들어줌

엔티티를 폼으로 써버리면 화면을 처리하는 기능이 증가된다. -> 화면 기능때문에 엔티티가 지저분해진다 -> 유지보수가 어려워짐
실무에서는 엔티티는 핵심  비즈니스 로직만 가지고있어야한다.
화면 관련된 것은 form이나 dto객체를 따로 만들어서 사용하는게 권장된다.

**api를 만들때는 절대 엔티티를 외부로 반환하면 안된다.**

## 변경감지와 병합(merge)
**준영속 엔티티**
영속성 컨텍스트가 더는 관리하지 않는 엔티티를 말한다. -> 데이터베이스에서 갔다 온 상태에서 식별자가 있는 상태면 준영속 상태라한다.
(준영속 엔티티는 `itemService.saveItem(book)` 에서 수정을 시도하는 `Book`  객체다. `Book`객체는 이미 DB에 한번 저장되어서 식별자가 존재한다. 이렇게 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있다.)

**병합 동작 방식**
![](2022-01-13-JPA-%E1%84%8B%E1%85%B0%E1%86%B8%E1%84%80%E1%85%A8%E1%84%8E%E1%85%B3%E1%86%BC%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF/7FB0961D-0FC7-4A1B-86C0-BA7C88F04115.png)

1. `merge()`를 실행한다.
2. 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회한다.
	1. 만약 1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고, 1차 캐시에 저장한다.
3. 	조회한 영속 엔티티(`mergeMember`)에 `member` 엔티티의 값을 채워 넣는다,(member 엔티티의 모든 값을 mergerMember에 밀어 넣는다. 이때 mergeMember의 “회원1”이라는 이름이 “회원명변경”으로 바뀐다,)
4. 영속 상태인 mergeMember를 반환한다.  

**병합시 동작 방식을 간단히 정리**
1. 준영속 엔티티의 식별자 값으로 영속 엔티티를 조회한다.
2. 영속 엔티티의 값을 준영속 엔티티의 값으로 모두 교체한다.(병합한다.)
3. 트랜잭션 커밋 시점에 변경 감지 기능이 동작해서 데이터베이스에 UPDATE SQL이 실행

* 주의: 변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경된다.
* 병합 시 값이 없으면 `null`로 업데이트 할 위험이 있다.(병합은 모든 필드를 교체한다.)

## -> 조금 귀찮더라도 merge 보다는 변경 감지를 사용해야한다. merge는 쓰지 말자
```java
@Transactional
public void updateItem(Long itemId, String name, int price, int stockQuantity) {
    Item findItem = itemRepository.findOne(itemId);
    findItem.setName(name);
    findItem.setPrice(price);
    findItem.setStockQuantity(stockQuantity);
}
```

**엔티티를 변경할 때는 항상 변경 감지를 사용해라**
* 컨트롤러에서 어설프게 엔티티를 생성하지 말자
* 트랜잭션이 있는 서비스 계층에 식별자(`id`)와 변경할 데이터를 명확하게 전달해라(파라미터 or DTO)
* 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회하고, 엔티티의 데이터를 직접 변경해라.
* 트랜잭션 커밋 시점에 변경감지가 실행된다.