---
layout: post
title: 객체지향의 사실과 오해 - 부록
description: 
summary: 
tags: 객체지향의 사실과 오해
minute: 1






---



# 부록



### 추상화 기법



추상화는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는데 사용할 수 있는 가장 기본적인 인지 수단이다. 개념을 구조화하고 단순화하기 위해 다양한 추상화 기법을 사용한다. 특성을 공유하는 객체들은 동일한 타입으로 분류하는 것은 객체지향 패러다임에서 사용하는 추상화 기법의 한 예다.

다음은 중요한 추상화 기법의 종류를 나타낸 것이다. 각 추상화 기법은 복잡성을 낮추기 위해 사물의 특정한 측면을 감춘다.

- **분류와 인스턴스화**: **분류**는 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정이다. 분류의 역은 범주로부터 객체를 생성하는 **인스턴스화** 과정이다.
- **일반화와 특수화**: **일반화**는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다. 일반화의 역을 **특수화**라 한다.
- **집합과 분해**: **집합**은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정을 가리킨다. 집합의 반대 과정은 전체를 부분으로 분리하는 **분해** 과정이다.





### 분류와 인스턴스화



**개념과 범주**

객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미한다. 개념이란 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어다.

세상에 존재하는 객체에 개념을 적용하는 과정을 분류라고 한다. 분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킨다. 

사람들은 분류를 통해 개별 현상을 하나의 개념으로 다룬다. 이때 '수많은 개별적인 현상들'을 **객체**라고 하고, '하나의 개념'을 **타입**이라고 한다. 분류는 객체를 타입과 연관시키는 것이다. 분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 **인스턴스화** 또는 **예시**라고 한다.

객체지향의 세계에서 개념을 가리키는 표준 용어는 타입이다. 따라서 타입은 개념과 동의어이며 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어를 의미한다. 이런 관점에서 분류란 객체들을 동일한 타입 또는 범주로 묶는 과정을 의미하므로 객체를 타입의 인스턴스라고 한다.





**타입**

타입을 객체의 분류 장치로서 적용할 수 있으려면 다음과 같은 세 가지 관점에서 정의가 필요하다.

- **심볼**: 타입을 가리키는 간략한 이름이나 명칭
- **내연**: 타입의 완전한 정의, 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.
- **외연**: 타입에 속하는 모든 객체들의 집합

도메인을 분석하는 동안 이름과 의미, 객체들의 집합을 이용해 개념(타입)을 정의할 수 있다.





**외연과 집합**

타입의 외연은 타입에 속하는 객체들의 집합으로 표현한다. 집합은 외연을 가리키는 또 다른 명칭이다. 객체들은 동시에 서로 다른 집합에 포함될 수도 있다.

한 객체가 한 시점에 하나의 타입에만 속하는 것을 **단일 분류(single classification)**라고 한다. 반면 한 객체가 한 시점에 여러 타입에 속할 경우 이를 **다중 분류(multiple classification)**라고 한다.

대부분 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다. 한 객체는 오직 한 클래스의 인스턴스여야만 하며 동시에 두 개의 클래스의 인스턴스일 수는 없다. 다중 상속은 하나의 타입이 다수의 슈퍼타입을 가질 수 있도록 허용하지만 타입 정의를 생략할 수는 없다. 반면 다중 분류는 특정한 타입을 정의하지 않고도 하나의 객체가 서로 다른 타입의 인스턴스가 되도록 허용한다.

객체를 특정한 타입으로 분류하면 해당 객체는 타입의 집합에 포함된다. 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우 이를 **동적 분류(dynamic classification)**이라고 한다. 객체가 자신의 타입을 변경할 수 없는 경우 이를 **정적 분류(static classification)**라고 한다.

대부분의 언어는 정적 분류만 허용하며 동적 분류를 구현할 수 있는 방법을 제공하지 않는다.





**클래스**

객체지향 프로그래밍 언어를 이용해 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다.

만약 객체들이 동일한 특성을 가진다면 그것들은 동일한 카테고리에 속한다. 객체들의 카테고리는 객체들이 공유하는 공통적인 특성에 의해 정의된다.





### 일반화와 특수화



**서브타입**



객체지향의 세계에서 범주는 개념을 의미하고, 개념은 타입을 의미하므로 일반화와 특수화는 계층 구조 안에 존재하는 타입 간의 관계를 의미한다. 어떤 타입이 다른 타입보다 일반적이라면 이 타입을 **슈퍼타입(supertype)**이라고 한다. 어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입을 **서브타입(subtype)**이라고 한다. 슈퍼타입은 서브타입의 일반화이고 서브타입은 슈퍼타입의 특수화다.

크레이그 라만은 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 **'100% 규칙'**과 **'Is-a 규칙'**을 준수해야 한다고 말한다. 100% 규칙은 타입의 내연과 관련된 규칙이며, Is-a 규칙은 타입의 외연과 관련된 규칙이다. 두 타입이 100% 규칙과 Is-a 규칙을 만족시키지 못할 경우 두 타입 간에 일반화 관계는 성립하지 않는다.

- 100% 규칙: 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다. 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다.
- Is-a 규칙: 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. 이는 대게 영어로 서브타입은 슈퍼타입이다.(subtype is a supertype)라는 구문을 만듦으로써 테스트할 수 있다.

Is-a 규칙에서 알 수 있는 것처럼 흔히 일반화 관계를 **is-a 관계**라고 한다. "고양이는 육식동물이다"와 "육식동물은 고양이다"라는 말은 두 가지 범주 간의 일반화 관계를 표현한 것이다. is-a 관계의 본직은 서브타입이 슈퍼타입의 부분집합이라는 것이다.

